(gitk >/dev/null 2>&1 &)

$git help

git config --global core.editor

leo@leo ~/works/PHP/GIT/TEST $ git config --list
user.name=Leonid
user.email=antropoid2017@gmail.com
core.autocrlf=input
merge.tool=meld
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true


$ git init      |      $ git clone git://github.com/schacon/grit.git mygrit


$git status
$git add README

.gitignore
Glob-шаблоны представляют собой упрощённые регулярные выражения используемые командными интерпретаторами. Символ * соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; [0-9] соответствует любому символу из интервала (в данном случае от 0 до 9).
name/    - каталог name

# комментарий — эта строка игнорируется
# не обрабатывать файлы, имя которых заканчивается на .a
*.a
# НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
!lib.a
# игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
/TODO
# игнорировать все файлы в каталоге build/
build/
# игнорировать doc/notes.txt, но не doc/server/arch.txt
doc/*.txt
# игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt

вы можете используя git diff посмотреть непроиндексированные изменения
а также уже проиндексированные, используя git diff --cached |  git diff --staged


$ git commit -m "Story 182: Fix benchmarks for speed"
$ git commit -m -a "Story 182: Fix benchmarks for speed"

git rm file.name   удалить его из отслеживаемых файлов и также удаляет файл из вашего рабочего каталога

$ git rm --cached readme.txt  удалить файл из индекса, оставив его при этом в рабочем каталоге

$ git mv README.txt README       переименовать(переместить в) README.txt -> README 
это эквивалентно выполнению следующих команд:
$ mv README.txt README
$ git rm README.txt
$ git add README

git log -p -2 выводит список коммитов созданных в данном репозитории -2, что ограничит вывод до 2-х последних записей. -p  все изменения ?

git log --pretty=format:"%h %s" --graph  параметр добавляет миленький ASCII-граф, показывающий историю ветвлений и слияний.


$ git commit --amend     Эта команда берёт индекс и использует его для коммита. Если после последнего коммита не было никаких изменений (например, вы запустили приведённую команду сразу после предыдущего коммита), то состояние проекта будет абсолютно таким же и всё, что вы измените, это комментарий к коммиту.

Отмена индексации файла
$ git reset HEAD benchmarks.rb  Файл benchmarks.rb изменён, но снова не в индексе.


чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним unstage:
$ git config --global alias.unstage 'reset HEAD --'
Это делает следующие две команды эквивалентными:
$ git unstage fileA
$ git reset HEAD fileA




Как быстро отменить изменения, вернуть то состояние, в котором он находился во время последнего коммита (или первоначального клонирования, или какого-то другого действия, после которого файл попал в рабочий каталог)?
$ git checkout -- benchmarks.rb
все сделанные вами изменения в этом файле пропали — вы просто скопировали поверх него другой файл. Никогда не используйте эту команду, если вы не полностью уверены, что этот файл вам не нужен



git remote. Она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов. 

Чтобы посмотреть, какому URL соответствует сокращённое имя в Git, можно указать команде опцию -v:
$ git remote -v


для получения данных из удалённых проектов, следует выполнить:
$ git fetch [имя удал. сервера]
Важно отметить, что команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.  ???????


$ git push origin master  Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.


метка — это что-то весьма похожее на ветку,  указатель на определённый коммит.
Создание аннотированной метки
$ git tag -a v1.4 -m 'my version 1.4'
$ git show v1.4


Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:
$ git tag -a v1.2 -m 'version 1.2' 9fceb02
$git tag
$git show v1.2

По умолчанию, команда git push не отправляет метки на удалённые серверы. 
нужно выполнить git push origin [имя метки].     origin ???

можно использовать опцию --tags для команды git push. В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).
$ git push origin --tags



